[
  {
    "path": "infovis/InfoVis1-Demo-ggplot/",
    "title": "Demo ggplot2",
    "description": {},
    "author": [],
    "date": "2021-10-21",
    "categories": [
      "InfoVis1"
    ],
    "contents": "\n\nContents\nBase-plot vs. ggplot\nLong vs. wide\nBeschriftungen (labels)\nX/Y-Achse anpassen\nThemes\nFacets / Small Multiples\nIn Variabel abspeichern und Exportieren\nSmoothing\n\n\nR-Code\n\n\n\nlibrary(readr)\nlibrary(lubridate)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\n\n\n\nAls erstes laden wir den Temperaturdatensatz ein. Es handelt sich dabei um eine leicht modifizierte Variante der Daten aus PrePro1 und PrePro2.\n\n\n# Wir können den Datensatz direkt über den URL einladen oder aber ihr nutzt den \n# URL um den Datensatz lokal bei euch abzuspeichern und wie gewohnt einzulesen\ntemperature <- read_csv(\"https://github.com/ResearchMethods-ZHAW/datasets/raw/main/infovis/temperature_SHA_ZER.csv\")\n\n\n\n\ntime\nSHA\nZER\n2000-01-01 00:00:00\n0.2\n-8.8\n2000-01-01 01:00:00\n0.3\n-8.7\n2000-01-01 02:00:00\n0.3\n-9.0\n2000-01-01 03:00:00\n0.3\n-8.7\n2000-01-01 04:00:00\n0.4\n-8.5\n2000-01-01 05:00:00\n0.5\n-8.4\n\nBase-plot vs. ggplot\nUm in “base-R” einen Scatterplot zu erstellen wo Datum der Temperatur gegenübersteht, gehen wir wie folgt vor:\n\n\nplot(temperature$time, temperature$SHA, type = \"l\", col = \"red\")\nlines(temperature$time, temperature$ZER, col = \"blue\")\n\n\n\n\nIn ggplot sieht das etwas anders und auf den ersten Blick etwas komplizierter aus: Ein plot wird durch den Befehl ggplot() initiiert. Hier wird einerseits der Datensatz festgelegt, auf dem der Plot beruht (data =), sowie die Variablen innerhalb des Datensatzes, die Einfluss auf den Plot ausüben (mapping = aes()).\n\n\n# Datensatz: \"temperature\" | Beeinflussende Variabeln: \"time\" und \"temp\"\nggplot(data = temperature, mapping = aes(time,SHA))             \n\n\n\n\nWeiter braucht es mindestens ein “Layer” der beschreibt, wie die Daten dargestellt werden sollen (z.B. geom_point()). Anders als bei “Piping” (%>%) wird ein Layer mit + hinzugefügt.\n\n\nggplot(data = temperature, mapping = aes(time,SHA)) +         \n  # Layer: \"geom_point\" entspricht Punkten in einem Scatterplot \n  geom_point()                                    \n\n\n\n\nDa ggplot die Eingaben in der Reihenfolge data = und dann mapping =erwartet, können wir diese Spezifizierungen auch weglassen.\n\n\nggplot(temperature, aes(time,SHA)) +\n  geom_point()\n\n\n\nLong vs. wide\nWie wir in PrePro 2 bereits erwähnt haben, ist ggplot2 auf long tables ausgelegt. Wir überführen deshalb an dieser Stelle die breite in eine lange Tabelle:\n\n\ntemperature_long <- pivot_longer(temperature, -time, names_to = \"station\", values_to = \"temp\")\n\n\n\nNun wollen wir die unterschiedlichen Stationen unterschiedlich einfärben. Da wir Variablen definieren wollen, welche Einfluss auf die Grafik haben sollen, gehört diese Information in aes().\n\n\nggplot(temperature_long, aes(time,temp, colour = station)) +\n  geom_point()\n\n\n\n\nWir können noch einen Layer mit Linien hinzufügen:\n\n\nggplot(temperature_long, aes(time,temp, colour = station)) +\n  geom_point()+\n  geom_line()\n\n\n\n\nBeschriftungen (labels)\nWeiter können wir die Achsen beschriften und einen Titel hinzufügen. Zudem lasse ich die Punkte (geom_point()) nun weg, da mir diese nicht gefallen.\n\n\nggplot(temperature_long, aes(time,temp, colour = station)) +\n  geom_line() +\n  labs(\n    x = \"Zeit\",\n    y = \"Temperatur in Grad C°\", \n    title = \"Temperaturdaten Schweiz\",\n    subtitle = \"2001 bis 2002\",\n    color = \"Station\"\n    )\n\n\n\n\nIm obigen Plot fällt auf, dass stündliche Werte eine zu hohe Auflösung ist, wenn wir daten über 2 Jahre visualisieren. Mit Split Apply Combine (PrePro 3) können wir die Auflösung unserer Daten verändern:\n\n\ntemperature_day <- temperature_long %>%\n  mutate(time = as.Date(time)) \n\ntemperature_day\n\n\n# A tibble: 35,088 × 3\n   time       station  temp\n   <date>     <chr>   <dbl>\n 1 2000-01-01 SHA       0.2\n 2 2000-01-01 ZER      -8.8\n 3 2000-01-01 SHA       0.3\n 4 2000-01-01 ZER      -8.7\n 5 2000-01-01 SHA       0.3\n 6 2000-01-01 ZER      -9  \n 7 2000-01-01 SHA       0.3\n 8 2000-01-01 ZER      -8.7\n 9 2000-01-01 SHA       0.4\n10 2000-01-01 ZER      -8.5\n# … with 35,078 more rows\n\ntemperature_day <- temperature_day %>%\n  group_by(station, time) %>%\n  summarise(temp = mean(temp))\n\n\n\nX/Y-Achse anpassen\nMan kann auch Einfluss auf die x-/y-Achsen nehmen. Dabei muss man zuerst festlegen, was für ein Achsentyp der Plot hat (vorher hat ggplot eine Annahme auf der Basis der Daten getroffen).\nBei unserer y-Achse handelt es sich um numerische Daten, ggplot nennt diese: scale_y_continuous(). Unter ggplot2.tidyverse.org findet man noch andere x/y-Achsentypen (scale_x_irgenwas bzw. scale_y_irgendwas).\n\n\nggplot(temperature_day, aes(time,temp, colour = station)) +\n  geom_line() +\n  labs(\n    x = \"Zeit\",\n    y = \"Temperatur in Grad C°\", \n    title = \"Temperaturdaten Schweiz\",\n    subtitle = \"2001 bis 2002\",\n    color = \"Station\"\n    ) +    \n  scale_y_continuous(limits = c(-30,30))    # y-Achsenabschnitt bestimmen\n\n\n\n\nDas gleiche Spiel kann man für die y-Achse betreiben. Bei unserer y-Achse handelt es sich ja um Datumsangaben. ggplot nennt diese: scale_x_date().\n\n\nggplot(temperature_day, aes(time,temp, colour = station)) +\n  geom_line() +\n  labs(\n    x = \"Zeit\",\n    y = \"Temperatur in Grad C°\", \n    title = \"Temperaturdaten Schweiz\",\n    subtitle = \"2001 bis 2002\",\n    color = \"Station\"\n    ) +    \n  scale_y_continuous(limits = c(-30,30)) +\n  scale_x_date(date_breaks = \"3 months\", \n                   date_labels = \"%b\")\n\n\n\n\nThemes\nMit theme verändert man das allgmeine Layout der Plots. Beispielsweise kann man mit theme_classic() ggplot-Grafiken etwas weniger “Poppig” erscheinen lassen: so sind sie besser für Bachelor- / Masterarbeiten sowie Publikationen geeignet. theme_classic() kann man indiviudell pro Plot anwenden, oder für die aktuelle Session global setzen (s.u.)\nIndividuell pro Plot:\n\n\nggplot(temperature_day, aes(time,temp, colour = station)) +\n  geom_line() +\n  theme_classic()\n\n\n\nGlobal (für alle nachfolgenden Plots der aktuellen Session):\n\n\ntheme_set(theme_classic())\n\n\n\nFacets / Small Multiples\nSehr praktisch sind auch die Funktionen für “Small multiples”. Dies erreicht man mit facet_wrap() (oder facet_grid(), mehr dazu später). Man muss mit einem Tilde-Symbol “~” nur festlegen, welche Variable für das Aufteilen des Plots in kleinere Subplots verantwortlich sein soll.\n\n\nggplot(temperature_day, aes(time,temp, colour = station)) +\n  geom_line() +\n  labs(\n    x = \"Zeit\",\n    y = \"Temperatur in Grad C°\", \n    title = \"Temperaturdaten Schweiz\",\n    subtitle = \"2001 bis 2002\",\n    color = \"Station\"\n    ) +    \n  scale_y_continuous(limits = c(-30,30)) +\n  scale_x_date(date_breaks = \"3 months\", \n                   date_labels = \"%b\") +\n  facet_wrap(station~.)\n\n\n\n\nAuch facet_wrap kann man auf seine Bedürfnisse anpassen: Beispielweise kann man mit ncol = die Anzahl facets pro Zeile bestimmen.\nZudem brauchen wir die Legende nicht mehr, da der Stationsnamen über jedem Facet steht. Ich setze deshalb theme(legend.position=\"none\")\n\n\nggplot(temperature_day, aes(time,temp, colour = station)) +\n  geom_line() +\n  labs(\n    x = \"Zeit\",\n    y = \"Temperatur in Grad C°\", \n    title = \"Temperaturdaten Schweiz\",\n    subtitle = \"2001 bis 2002\"\n    ) +  \n  scale_y_continuous(limits = c(-30,30)) +\n  scale_x_date(date_breaks = \"3 months\", \n                   date_labels = \"%b\") +\n  facet_wrap(~station,ncol = 1) +\n  theme(legend.position=\"none\")\n\n\n\n\nIn Variabel abspeichern und Exportieren\nGenau wie data.frames und andere Objekte, kann man einen ganzen Plot auch in einer Variabel speichern. Dies kann nützlich sein um einen Plot zu exportieren (als png, jpg usw.) oder sukzessive erweitern wie in diesem Beispiel.\n\n\np <- ggplot(temperature_day, aes(time,temp, colour = station)) +\n  geom_line() +\n  labs(\n    x = \"Zeit\",\n    y = \"Temperatur in Grad C°\", \n    title = \"Temperaturdaten Schweiz\",\n    subtitle = \"2001 bis 2002\"\n    ) +\n  scale_y_continuous(limits = c(-30,30)) +\n  scale_x_date(date_breaks = \"3 months\", \n                   date_labels = \"%b\") +\n  facet_wrap(~station,ncol = 1)\n  # ich habe an dieser Stelle theme(legend.position=\"none\") entfernt\n\n\n\nFolgendermassen kann ich den Plot als png-File abspeichern (ohne Angabe von “plot =” wird einfach der letzte Plot gespeichert)\n\n\nggsave(filename = \"plot.png\",plot = p)\n\n\n\n.. und so kann ich einen bestehenden Plot (in einer Variabel) mit einem Layer / einer Option erweitern\n\n\np +\n  theme(legend.position=\"none\")\n\n\n\nWie üblich wurde diese Änderung nicht gespeichert, sondern nur das Resultat davon ausgeben. Wenn die Änderung in meinem Plot (in der Variabel) abspeichern will, muss ich die Variabel überschreiben:\n\n\np <- p +\n  theme(legend.position=\"none\")\n\n\n\nSmoothing\nMit geom_smooth() kann ggplot eine Trendlinie auf der Baiss von Punktdaten berechnen. Die zugrunde liegende statistische Methode kann selbst gewählt werden (ohne Angabe verwendet ggplot bei < 1’000 Messungen stats::loess, ansonsten mgcv::gam)\n\n\np <- p +\n  geom_smooth(colour = \"black\")\n\np\n\n\n\n\n\n\n\n",
    "preview": "infovis/InfoVis1-Demo-ggplot/distill-preview.png",
    "last_modified": "2021-11-04T12:47:16+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "infovis/InfoVis1-Script-EDA/",
    "title": "Script EDA",
    "description": {},
    "author": [],
    "date": "2021-10-26",
    "categories": [
      "InfoVis1"
    ],
    "contents": "\n\nR-Code\n\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(scales)\n\n# create some data about age and height of people\npeople <- data.frame(\n  ID = c(1:30),\n  \n  age = c(5.0, 7.0, 6.5 ,9.0, 8.0, 5.0, 8.6, 7.5, 9.0, 6.0,\n          63.5 ,65.7, 57.6, 98.6, 76.5, 78.0, 93.4, 77.5, 256.6, 512.3,\n          15.5, 18.6, 18.5, 22.8, 28.5, 39.5, 55.9, 50.3, 31.9, 41.3),\n  \n  height = c(0.85, 0.93, 1.1, 1.25, 1.33, 1.17, 1.32, 0.82, 0.89, 1.13,\n             1.62, 1.87, 1.67, 1.76, 1.56, 1.71, 1.65, 1.55, 1.87, 1.69,\n             1.49, 1.68, 1.41, 1.55, 1.84, 1.69, 0.85, 1.65, 1.94, 1.80),\n  \n  weight = c(45.5, 54.3, 76.5, 60.4, 43.4, 36.4, 50.3, 27.8, 34.7, 47.6,\n             84.3, 90.4, 76.5, 55.6, 54.3, 83.2, 80.7, 55.6, 87.6, 69.5,\n             48.0, 55.6, 47.6, 60.5, 54.3, 59.5, 34.5, 55.4, 100.4, 110.3)\n)\n\n\n\n# build a scatterplot for a first inspection\nggplot(people, aes(x=age, y=height)) + \n  geom_point() \n\n\n\nggplot(people, aes(x=age, y=height)) + \n  geom_point() +\n  scale_y_continuous(limits = c(0.75, 2))\n\n\n\n# Go to help page: http://docs.ggplot2.org/current/ -> Search for icon of fit-line\n# http://docs.ggplot2.org/current/geom_smooth.html\n\n# build a scatterplot for a first inspection, with regression line\nggplot(people, aes(x=age, y=height)) + \n  geom_point() + \n  scale_y_continuous(limits=c(0, 2.0)) +\n  geom_smooth()\n\n\n\n# stem and leaf plot\nstem(people$height)\n\n\n\n  The decimal point is 1 digit(s) to the left of the |\n\n   8 | 25593\n  10 | 037\n  12 | 523\n  14 | 19556\n  16 | 255789916\n  18 | 04774\n\nstem(people$height, scale=2)\n\n\n\n  The decimal point is 1 digit(s) to the left of the |\n\n   8 | 2559\n   9 | 3\n  10 | \n  11 | 037\n  12 | 5\n  13 | 23\n  14 | 19\n  15 | 556\n  16 | 2557899\n  17 | 16\n  18 | 0477\n  19 | 4\n\n# explore the two variables with box-whiskerplots\nsummary(people$age)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   5.00    8.70   30.20   59.14   65.15  512.30 \n\nboxplot(people$age)\n\n\n\nsummary(people$height)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.820   1.190   1.555   1.455   1.690   1.940 \n\nboxplot(people$height)\n\n\n\n# explore data with a histgram\nggplot(people, aes(x=age)) + \n  geom_histogram(binwidth=20)  \n\n\n\ndensity(x = people$height)\n\n\n\nCall:\n    density.default(x = people$height)\n\nData: people$height (30 obs.);  Bandwidth 'bw' = 0.1576\n\n       x                y           \n Min.   :0.3472   Min.   :0.001593  \n 1st Qu.:0.8636   1st Qu.:0.102953  \n Median :1.3800   Median :0.510601  \n Mean   :1.3800   Mean   :0.483553  \n 3rd Qu.:1.8964   3rd Qu.:0.722660  \n Max.   :2.4128   Max.   :1.216350  \n\n# re-expression: use log or sqrt axes\n#\n# Find here guideline about scaling axes \n# http://www.cookbook-r.com/Graphs/Axes_(ggplot2)/\n# http://docs.ggplot2.org/0.9.3.1/scale_continuous.html\n\n\n# logarithmic axis: respond to skewness in the data, e.g. log10 \nggplot(people, aes(x=age, y=height)) + \n  geom_point() + \n  scale_y_continuous(limits=c(0, 2.0)) +\n  geom_smooth() +\n  scale_x_log10()\n\n\n\n# outliers: Remove very small and very old people\n\npeopleClean <- people %>%\n  filter(ID != 27) %>%    # Diese Person war zu klein.\n  filter(age < 100)       # Fehler in der Erhebung des Alters\n\nggplot(peopleClean, aes(x=age)) + \n  geom_histogram(binwidth=10)\n\n\n\nggplot(peopleClean, aes(x=age, y=height)) + \n  geom_point() + \n  scale_y_continuous(limits=c(0, 2.0)) +\n  geom_smooth()\n\n\n\n# with custom binwidth\nggplot(peopleClean, aes(x=age)) + \n  geom_histogram(binwidth=10) + \n  theme_bw() # specifying the theme\n\n\n\n# quadratic axis\nggplot(peopleClean, aes(x=age, y=height)) + \n  geom_point() + scale_y_continuous(limits=c(0, 2.0)) +\n  geom_smooth(method=\"lm\", fill='lightblue', size=0.5, alpha=0.5) + \n  scale_x_sqrt()\n\n\n\n# filter \"teenies\": No trend\nfilter(peopleClean, age < 15) %>%\n  ggplot(aes(x=age, y=height)) + \n  geom_point() + \n  scale_y_continuous(limits=c(0, 2.0)) +\n  geom_smooth(method=\"lm\", fill='lightblue', size=0.5, alpha=0.5)\n\n\n\n# filter \"teenies\": No trend\npeopleClean %>%\n  filter(age > 55) %>%\n  ggplot(aes(x=age, y=height)) + \n  geom_point() + \n  scale_y_continuous(limits=c(0, 2.0)) +\n  geom_smooth(method=\"lm\", fill='lightblue', size=0.5, alpha=0.5)\n\n\n\n# Onwards towards multidimensional data\n\n# Finally, make a scatterplot matrix\npairs(peopleClean[,2:4], panel=panel.smooth)\n\npairs(peopleClean[,2:4], panel=panel.smooth)\n\n\n\n\n\n\n\n",
    "preview": "infovis/InfoVis1-Script-EDA/distill-preview.png",
    "last_modified": "2021-11-04T12:47:16+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "infovis/InfoVis1-Uebung/",
    "title": "Übung",
    "description": {},
    "author": [],
    "date": "2021-11-01",
    "categories": [
      "InfoVis1"
    ],
    "contents": "\nIn dieser Übung geht es darum, die Grafiken aus dem Blog-post Kovic (2014) zu rekonstruieren. Schau dir die Grafiken in dem Blogpost durch. Freundlicherweise wurden im Blogbeitrag die ggplot2 Standardeinstellungen benutzt, was die Rekonstruktion relativ einfach macht. Die Links im Text verweisen auf die Originalgrafik, die eingebetteten Plots sind meine eigenen Rekonstruktionen.\nImportiere als erstes den Datensatz initiative_masseneinwanderung_kanton.csv (dieser ist auch auf der Blog-Seite verfügbar).\n\n\n\nAufgabe 1\nRekonstruiere Grafik 1 (Kovic 2014). Erstelle dazu einen Scatterplot wo der Ausländeranteil der Kantone dem Ja-Anteil gegenüber gestellt wird. Speichere den Plot einer Variabel plot1.\nnutze ggplot(kanton, aes(auslanderanteil, ja_anteil)) um den ggplot zu initiieren. Füge danach ein einen Punkte Layer hinzu (geom_point())\nnutze coord_fixed() um die beiden Achsen in ein fixes Verhältnis zu setzen (1:1).\nOptional:\nsetze die Achsen Start- und Endwerte mittels scale_y_continuous bzw. scale_x_continuous.\nSetze analog Kovic (2014) die breaks (0.0, 0.1…0.7) manuell (innerhalb scale_*_continuous)\n\nRekonstruktion:\n\n\n\nAufgabe 2\nRekonstruiere Grafik 2. Erweitere dazu plot1 mit einer Trendlinie.\n\n\n\nAufgabe 3\nImportiere die Gemeindedaten initiative_masseneinwanderung_gemeinde.csv. Rekonstruiere danach Grafik 3 indem du den Ausländeranteil aller Gemeinden dem Ja-Stimmen-Anteil gegenüber. Speichere den Plot als plot2\n\n\n\nAufgabe 4\nRekonstruiere Grafik 4 indem plot2 mit einer Trendlinie erweitert wird.\n\n\n\nAufgabe 5\nRekonstruiere Grafik 5 indem plot2 mit facetting erweitert wird. Die Facets sollen die einzelnen Kantone sein. Speichere den Plot als plot3.\n\n\n\nAufgabe 6\nRekonstruiere Grafik 6 indem plot3 mit einer Trendlinie erweitert wird.\nRekonstruktion:\n\n\n\nAufgabe 7\nRekonstruiere Grafik 7 indem plot2mit facetting erweitert wird. Die Facets sollen nun den Grössen-Quantilen entsprechen. Speichere den Plot unter plot4.\nRekonstruktion:\n\n\n\nAufgabe 8\nRekonstruiere Grafik 8 indem plot4 mit einer Trendlinie ausgestattet wird.\n\n\n\nAufgabe 9 (Optional, fortgeschritten)\nRekonstruiere die Korrelationstabelle.\nTipp: - Nutze group_by() und summarise() - Nutze cor.test() um den Korrelationskoeffizienten sowie den p-Wert zu erhalten. - Mit $estimate und $p.value können die entsprechenden Werte direkt angesprochen werden\nHinweis: aus bisher unerklärlichen Gründen weiche gewisse meiner Werte leicht von den Berechnungen aus Kovic (2014) ab.\n\n\n\n\nTable 1: Legende: * = p<0.05, ** = p<0.01, ***=p<0.001.\nkanton\nKorr.Koeffizient\nSignifikanz\nAG\n-0.2362552\n***\nAI\n-0.7828022\n-\nAR\n-0.0892817\n-\nBE\n-0.4422003\n***\nBL\n-0.2919712\n**\nBS\n-0.9935385\n-\nFR\n-0.4217634\n***\nGE\n0.3753004\n*\nGL\n-0.4070120\n-\nGR\n-0.0426607\n-\nJU\n-0.2252540\n-\nLU\n-0.3048455\n**\nNE\n-0.5214180\n***\nNW\n-0.2018174\n-\nOW\n-0.4813090\n-\nSG\n-0.2449093\n*\nSH\n-0.2995527\n-\nSO\n-0.0533442\n-\nSZ\n-0.7259276\n***\nTG\n-0.5522862\n***\nTI\n0.1512509\n-\nUR\n-0.3848167\n-\nVD\n-0.2685301\n***\nVS\n-0.1736954\n*\nZG\n0.0407166\n-\nZH\n-0.2744683\n***\n\nMusterlösung\n\nR-Code\n\n\n\n\nKovic, Marko. 2014. “Je Weniger Ausländer, Desto Mehr Ja-Stimmen? Wirklich?” Tagesanzeiger Datenblog. https://blog.tagesanzeiger.ch/datenblog/index.php/668/je-weniger-auslaender-desto-mehr-ja-stimmen-wirklich.\n\n\n\n\n",
    "preview": "infovis/InfoVis1-Uebung/distill-preview.png",
    "last_modified": "2021-11-04T12:47:16+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "infovis/InfoVis2-CairoWheel/",
    "title": "Cairo Wheel",
    "description": {},
    "author": [],
    "date": "2021-10-26",
    "categories": [
      "InfoVis2"
    ],
    "contents": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "preview": "infovis/InfoVis2-CairoWheel/distill-preview.png",
    "last_modified": "2021-11-04T12:47:16+00:00",
    "input_file": {},
    "preview_width": 3456,
    "preview_height": 2304
  },
  {
    "path": "infovis/InfoVis2-Uebung-A/",
    "title": "Übung A",
    "description": {},
    "author": [],
    "date": "2021-11-01",
    "categories": [
      "InfoVis2"
    ],
    "contents": "\n\n\n\nFür die heutige Übung brauchst du den Datensatz temperature_2005.csv. Dabei handelt es sich wieder um Teperaturwerte verschiedener Stationen, diesmal aus dem Jahr 2005. Das Datum ist so formatiert, dass R (isbesondere read_csv) es korrekt als datetime erkennen und als POSIXct einlesen sollte.\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(tidyr)\nlibrary(ggplot2)\n\n\n\n\n\n\n\n\n\nAufgabe 1\nMache aus der wide table eine long table die wie folgt aussieht.\n\ntime\nstation\ntemperature\n2005-01-01\nALT\n1.3\n2005-01-01\nBUS\n1.5\n2005-01-01\nGVE\n1.1\n2005-01-01\nINT\n0.2\n2005-01-01\nOTL\n2.2\n2005-01-01\nLUG\n1.7\n\nLade anschliessend temperature_2005_metadata.csv herunter und verbinde die beiden Datensätze mit einem left_join via station (bzw. stn).\n\n\n\nAufgabe 2\nErstelle ein Scatterplot (time vs. temperature) wobei die Punkte aufgrund ihrer Meereshöhe eingefärbt werden sollen. Tiefe Werte sollen dabei blau eingefärbt werden und hohe Werte rot (scale_color_gradient). Verkleinere die Punkte um übermässiges Überplotten der Punkten zu vermeiden (size =). Weiter sollen auf der x-Achse im Abstand von 3 Monaten der jeweilige Monat vermerkt sein (date_breaks bzw. date_labels von scale_x_datetime()).\n\n\n\nAufgabe 3\nErstelle eine Zusatzvariabel Date mit dem Datum der jeweiligen Messung ( mit as.Date). Nutze diese Spalte um die Tagesmitteltemperatur pro Station zu berechnen (mit summarise()).\nUm die Metadaten (Name, Meereshoehe, x, y) nicht zu verlieren kannst du den Join aus der ersten Übung wieder ausführen. Alternativ (schneller aber auch schwerer zu verstehen) kannst du diese Variabeln innerhalb deines group_by verwenden.\n\n\n\nAufgabe 4\nWiederhole nun den Plot aus der ersten Aufgabe mit den aggregierten Daten aus der vorherigen Aufgabe. Um die labels korrekt zu setzen musst du scale_x_datetime mit scale_x_date ersetzen.\n\n\n\nAufgabe 5\nFüge am obigen Plot eine schwarze, gestrichelte Trendlinie hinzu.\n\n\n\nAufgabe 6\nPositioniere die Legende oberhalb des Plots (nutze dazu theme() mit legend.position).\n\n\n\nAufgabe 7 (optional, fortgeschritten)\nFüge den Temperaturwerten auf der y-Ache ein °C hinzu (siehe unten und studiere diesen Tipp zur Hilfe).\n\n\n\nAufgabe 8\nJetzt verlassen wir den scatterplot und machen einen Boxplot mit den Temperaturdaten. Färbe die Boxplots wieder in Abhängigkeit der Meereshöhe ein.\nBeachte den Unterschied zwischen colour = und fill =\nBeachte den Unterschied zwischen facet_wrap() und facet_grid()\nfacet_grid() braucht übrigens noch einen Punkt (.) zur Tilde (~).\nBeachte den Unterschied zwischen “.~” und “~.” bei facet_grid()\nverschiebe nach Bedarf die Legende\n\n\n\nAufgabe 9\nAls letzter wichtiger Plottyp noch zwei Übungen zum Histogramm. Erstelle ein Histogramm geom_histogram() mit den Temperaturwerten. Teile dazu die Stationen in verschiedene Höhenlagen ein (Tieflage [< 400 m], Mittellage [400 - 600 m] und Hochlage [> 600 m]). Vergleiche die Verteilung der Temperaturwerte in den verschiedenen Lagen mit einem Histogramm.\nTip: Nutze cut um die Stationen in die drei Gruppen aufzuteilen\n\n\n\nMusterlösung\n\nR-Code\n\n\n\n\n",
    "preview": "infovis/InfoVis2-Uebung-A/distill-preview.png",
    "last_modified": "2021-11-04T12:47:16+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "infovis/InfoVis2-Uebung-B/",
    "title": "Übung B (Optional)",
    "description": {},
    "author": [],
    "date": "2021-11-01",
    "categories": [
      "InfoVis2"
    ],
    "contents": "\n\nContents\nAufgabe 1: Parallel coordinate plots\nAufgabe 2: Polar Plot mit Biber Daten\nAufgabe 3: Raster Visualisierung mit Flugpassagieren\nMusterlösung\n\nIn dieser Übung bauen wir einige etwas unübliche Plots aus der Vorlesung nach. Dafür verwenden wir Datensätze, die in R bereits integriert sind. Eine Liste dieser Datensätze findet man hier oder mit der Hilfe ?datasets.\nDazu verwenden wir nach wie vor ggplot2, aber mit einigen Tricks.\n\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\n\n\n\nAufgabe 1: Parallel coordinate plots\nErstelle einen parallel coordinate plot. Dafür eignet sich der integrierte Datensatz mtcars. Extrahiere die Fahrzeugnamen mit rownames_to_column.\nZudem müssen die Werte jeweiles auf eine gemeinsame Skala normalisiert werden. Hierfür kannst du die Funktion scales::rescale verwenden.\n\n\nmtcars2 <- mtcars %>%\n  tibble::rownames_to_column(\"car\") %>%\n  pivot_longer(-car)\n\nmtcars2 <- mtcars2 %>%\n  group_by(name) %>%\n  mutate(value_scaled = scales::rescale(value))\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\nMazda RX4\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\nMazda RX4 Wag\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\nHornet 4 Drive\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\nHornet Sportabout\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\nValiant\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\nSo sieht der fertige Plot aus:\n\n\nmtcars2 <- mtcars2 %>%\n  group_by(car) %>%\n  mutate(gear = value[name == \"gear\"])\n\nggplot(mtcars2, aes(name, value_scaled, group = car, color = factor(gear))) +\n  geom_point() +\n  geom_line() +\n  theme_minimal() +\n  theme(legend.position = \"none\", axis.title.y = element_blank())\n\n\n\n\nAufgabe 2: Polar Plot mit Biber Daten\nPolar Plots eignen sich unter anderem für Daten, die zyklischer Natur sind, wie zum Beispiel zeitlich geprägte Daten (Tages-, Wochen-, oder Jahresrhythmen). Aus den Beispiels-Datensätzen habe ich zwei Datensätze gefunden, die zeitlich geprägt sind:\nbeaver1 und beaver2 AirPassenger\nBeide Datensätze müssen noch etwas umgeformt werden, bevor wir sie für einen Radialplot verwenden können. In Aufgabe 2 verwenden wir die Biber-Datensätze, in der nächsten Aufgabe (3) die Passagier-Daten.\nWenn wir die Daten von beiden Bibern verwenden wollen, müssen wir diese noch zusammenfügen:\n\n\nbeaver1_new <- beaver1 %>%\n  mutate(beaver = \"nr1\")\n\nbeaver2_new <- beaver2 %>%\n  mutate(beaver = \"nr2\")\n\nbeaver_new <- rbind(beaver1_new,beaver2_new)\n\n\n\nZudem müssen wir die Zeitangabe noch anpassen: Gemäss der Datenbeschreibung handelt es sich bei der Zeitangabe um ein sehr programmier-unfreundliches Format. 3:30 wird als “0330” notiert. Wir müssen diese Zeitangabe, noch in ein Dezimalsystem umwandeln:\n\n\nbeaver_new <- beaver_new %>%\n  mutate(\n    hour_dec = (time/100)%/%1,         # Ganze Stunden (mittels ganzzaliger Division)\n    min_dec = (time/100)%%1/0.6,       # Dezimalminuten (15 min wird zu 0.25, via Modulo)\n    hour_min_dec = hour_dec+min_dec    # Dezimal-Zeitangabe (03:30 wird zu 3.5)\n    ) \n\n\n\nDer Datensatz:\n\nday\ntime\ntemp\nactiv\nbeaver\nhour_dec\nmin_dec\nhour_min_dec\n346\n840\n36.33\n0\nnr1\n8\n0.6666667\n8.666667\n346\n850\n36.34\n0\nnr1\n8\n0.8333333\n8.833333\n346\n900\n36.35\n0\nnr1\n9\n0.0000000\n9.000000\n346\n910\n36.42\n0\nnr1\n9\n0.1666667\n9.166667\n346\n920\n36.55\n0\nnr1\n9\n0.3333333\n9.333333\n346\n930\n36.69\n0\nnr1\n9\n0.5000000\n9.500000\n\nSo sieht der fertige Plot aus:\n\n\n# Lösung Aufgabe 2\n\nbeaver_new %>%\n  ggplot(aes(hour_min_dec, temp, color = beaver)) +\n  geom_point() +\n  scale_x_continuous(breaks = seq(0,23,2)) +\n  coord_polar() +\n  theme_minimal() +\n  theme(axis.title =  element_blank())\n\n\n\n\nAufgabe 3: Raster Visualisierung mit Flugpassagieren\nAnalog Aufgabe 2, dieses Mal mit dem Datensatz AirPassanger\nAirPassengers kommt in einem Format daher, das ich selbst noch gar nicht kannte. Es sieht zwar aus wie ein data.frame oder eine matrix, ist aber von der Klasse ts.\n\n\nAirPassengers\n\n\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n1949 112 118 132 129 121 135 148 148 136 119 104 118\n1950 115 126 141 135 125 149 170 170 158 133 114 140\n1951 145 150 178 163 172 178 199 199 184 162 146 166\n1952 171 180 193 181 183 218 230 242 209 191 172 194\n1953 196 196 236 235 229 243 264 272 237 211 180 201\n1954 204 188 235 227 234 264 302 293 259 229 203 229\n1955 242 233 267 269 270 315 364 347 312 274 237 278\n1956 284 277 317 313 318 374 413 405 355 306 271 306\n1957 315 301 356 348 355 422 465 467 404 347 305 336\n1958 340 318 362 348 363 435 491 505 404 359 310 337\n1959 360 342 406 396 420 472 548 559 463 407 362 405\n1960 417 391 419 461 472 535 622 606 508 461 390 432\n\nclass(AirPassengers)\n\n\n[1] \"ts\"\n\nDamit wir den Datensatz verwenden können, müssen wir ihn zuerst in eine matrix umwandeln. Wie das geht habe ich hier erfahren.\n\n\nAirPassengers2 <- tapply(AirPassengers, list(year = floor(time(AirPassengers)), month = month.abb[cycle(AirPassengers)]), c)\n\n\n\nAus der matrix muss noch ein Dataframe her, zudem müssen wir aus der breiten Tabelle eine lange Tabelle machen:\n\n\nAirPassengers3 <- AirPassengers2 %>%\n  as.data.frame() %>%\n  tibble::rownames_to_column(\"year\") %>%\n  pivot_longer(-year, names_to = \"month\", values_to = \"n\") %>%\n  mutate(\n    # ich nutze einen billigen Trick um ausgeschriebene Monate in Nummern umzuwandeln\n    month = factor(month, levels = month.abb,ordered = T),\n    month_numb = as.integer(month),\n    year = as.integer(year)\n  )\n\n\n\nSo sieht der fertige Plot aus:\n\n\n\nMusterlösung\n\nR-Code\n\n\n\n\n",
    "preview": "infovis/InfoVis2-Uebung-B/distill-preview.png",
    "last_modified": "2021-11-04T12:47:16+00:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 960
  }
]
